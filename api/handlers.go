package api

import (
	"database/sql"
	"fmt"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid" // <--- Import uuid package
	db "github.com/tedobanks/tabularasa_backend/db/sqlc"
	"golang.org/x/crypto/bcrypt"
)

// Helper function to create sql.NullString from a string
func newNullString(s string) sql.NullString {
	if len(s) == 0 {
		return sql.NullString{Valid: false}
	}
	return sql.NullString{String: s, Valid: true}
}

// Function to hash a password
func hashPassword(password string) (string, error) {
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return "", fmt.Errorf("failed to hash password: %w", err)
	}
	return string(hashedPassword), nil
}

// Function to check if a password matches a hash
func checkPassword(password string, hashedPassword string) error {
	return bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
}

// createUserRequest defines the request body for creating a new user.
type createUserRequest struct {
	Email     string `json:"email" binding:"required,email"`
	Password  string `json:"password" binding:"required,min=6"`
	Firstname string `json:"firstname"`
	Lastname  string `json:"lastname"`
	// If your DB schema uses UUIDs for the primary key (id) and it's generated by DB,
	// you won't include ID here. If it's sent from client, you'd add ID string `json:"id"`
	// and then parse it. For now, assuming DB generates ID.
}

// createUser handles the creation of a new user.
// POST /users
func (server *Server) createUser(ctx *gin.Context) {
	var req createUserRequest
	if err := ctx.ShouldBindJSON(&req); err != nil {
		ctx.JSON(http.StatusBadRequest, errorResponse(err))
		return
	}

	hashedPassword, err := hashPassword(req.Password)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, errorResponse(err))
		return
	}

	arg := db.CreateUserParams{
		Email:     req.Email,
		Password:  newNullString(hashedPassword),
		Firstname: newNullString(req.Firstname),
		Lastname:  newNullString(req.Lastname),
	}

	user, err := server.store.CreateUser(ctx, arg)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, errorResponse(err))
		return
	}

	ctx.JSON(http.StatusOK, user)
}

// getUserRequest defines the URI parameter for getting a user by ID.
type getUserRequest struct {
	// FIX: Change to string for binding, then parse to uuid.UUID
	ID string `uri:"id" binding:"required,uuid"` // Use 'uuid' binding for UUID string format
}

// getUser handles fetching a single user by ID.
// GET /users/:id
func (server *Server) getUser(ctx *gin.Context) {
	var req getUserRequest
	if err := ctx.ShouldBindUri(&req); err != nil {
		ctx.JSON(http.StatusBadRequest, errorResponse(err))
		return
	}

	// FIX: Parse the string ID into uuid.UUID
	uuidID, err := uuid.Parse(req.ID)
	if err != nil {
		ctx.JSON(http.StatusBadRequest, errorResponse(fmt.Errorf("invalid user ID format: %w", err)))
		return
	}

	user, err := server.store.GetUser(ctx, uuidID) // <--- Pass uuid.UUID
	if err != nil {
		if err == sql.ErrNoRows {
			ctx.JSON(http.StatusNotFound, errorResponse(fmt.Errorf("user not found")))
			return
		}
		ctx.JSON(http.StatusInternalServerError, errorResponse(err))
		return
	}

	ctx.JSON(http.StatusOK, user)
}

// getUserByEmailRequest defines the query parameter for getting a user by email.
type getUserByEmailRequest struct {
	Email string `form:"email" binding:"required,email"`
}

// getUserByEmail handles fetching a single user by email.
// GET /users/by-email?email=...
func (server *Server) getUserByEmail(ctx *gin.Context) {
	var req getUserByEmailRequest
	if err := ctx.ShouldBindQuery(&req); err != nil {
		ctx.JSON(http.StatusBadRequest, errorResponse(err))
		return
	}

	user, err := server.store.GetUserByEmail(ctx, req.Email)
	if err != nil {
		if err == sql.ErrNoRows {
			ctx.JSON(http.StatusNotFound, errorResponse(fmt.Errorf("user not found")))
			return
		}
		ctx.JSON(http.StatusInternalServerError, errorResponse(err))
		return
	}

	ctx.JSON(http.StatusOK, user)
}

// listUsersRequest defines optional query parameters for listing users (e.g., pagination).
type listUsersRequest struct {
	// You could add Limit int64 `form:"limit" binding:"min=1"`
	// You could add Offset int64 `form:"offset" binding:"min=0"`
}

// listUsers handles fetching a list of all users.
// GET /users
func (server *Server) listUsers(ctx *gin.Context) {
	var req listUsersRequest
	if err := ctx.ShouldBindQuery(&req); err != nil {
		ctx.JSON(http.StatusBadRequest, errorResponse(err))
		return
	}

	users, err := server.store.ListUsers(ctx)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, errorResponse(err))
		return
	}

	ctx.JSON(http.StatusOK, users)
}

// updateuserRequest defines the request body for updating a user.
type updateUserRequest struct {
	Email     string `json:"email" binding:"required,email"`
	Password  string `json:"password" binding:"required,min=6"`
	Firstname string `json:"firstname"`
	Lastname  string `json:"lastname"`
}

// updateUserURI defines the URI parameter for updating a user by ID.
type updateUserURI struct {
	// FIX: Change to string for binding, then parse to uuid.UUID
	ID string `uri:"id" binding:"required,uuid"` // Use 'uuid' binding for UUID string format
}

// updateUser handles updating an existing user.
// PUT /users/:id
func (server *Server) updateUser(ctx *gin.Context) {
	var uri updateUserURI
	if err := ctx.ShouldBindUri(&uri); err != nil {
		ctx.JSON(http.StatusBadRequest, errorResponse(err))
		return
	}

	// FIX: Parse the string ID into uuid.UUID
	uuidID, err := uuid.Parse(uri.ID)
	if err != nil {
		ctx.JSON(http.StatusBadRequest, errorResponse(fmt.Errorf("invalid user ID format: %w", err)))
		return
	}

	var req updateUserRequest
	if err := ctx.ShouldBindJSON(&req); err != nil {
		ctx.JSON(http.StatusBadRequest, errorResponse(err))
		return
	}

	hashedPassword, err := hashPassword(req.Password)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, errorResponse(err))
		return
	}

	arg := db.UpdateUserParams{
		ID:        uuidID, // <--- Pass uuid.UUID
		Email:     req.Email,
		Password:  newNullString(hashedPassword),
		Firstname: newNullString(req.Firstname),
		Lastname:  newNullString(req.Lastname),
	}

	user, err := server.store.UpdateUser(ctx, arg)
	if err != nil {
		if err == sql.ErrNoRows {
			ctx.JSON(http.StatusNotFound, errorResponse(fmt.Errorf("user not found for update")))
			return
		}
		ctx.JSON(http.StatusInternalServerError, errorResponse(err))
		return
	}

	ctx.JSON(http.StatusOK, user)
}

// deleteUserRequest defines the URI parameter for deleting a user by ID.
type deleteUserRequest struct {
	// FIX: Change to string for binding, then parse to uuid.UUID
	ID string `uri:"id" binding:"required,uuid"` // Use 'uuid' binding for UUID string format
}

// deleteUser handles deleting a user by ID.
// DELETE /users/:id
func (server *Server) deleteUser(ctx *gin.Context) {
	var req deleteUserRequest
	if err := ctx.ShouldBindUri(&req); err != nil {
		ctx.JSON(http.StatusBadRequest, errorResponse(err))
		return
	}

	// FIX: Parse the string ID into uuid.UUID
	uuidID, err := uuid.Parse(req.ID)
	if err != nil {
		ctx.JSON(http.StatusBadRequest, errorResponse(fmt.Errorf("invalid user ID format: %w", err)))
		return
	}

	err = server.store.DeleteUser(ctx, uuidID) // <--- Pass uuid.UUID
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, errorResponse(err))
		return
	}

	ctx.JSON(http.StatusNoContent, nil)
}
